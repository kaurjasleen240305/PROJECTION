"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _utils = require("@mui/utils");
var _composeClasses = require("@mui/base/composeClasses");
var _useBadge = require("@mui/base/useBadge");
var _base = require("@mui/base");
var _styled = _interopRequireDefault(require("../styles/styled"));
var _useTheme = _interopRequireDefault(require("../styles/useTheme"));
var _useThemeProps = _interopRequireDefault(require("../styles/useThemeProps"));
var _badgeClasses = _interopRequireWildcard(require("./badgeClasses"));
var _jsxRuntime = require("react/jsx-runtime");
const _excluded = ["anchorOrigin", "className", "classes", "component", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "size", "variant"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const useUtilityClasses = ownerState => {
  const {
    color,
    anchorOrigin,
    invisible,
    overlap,
    size,
    variant,
    classes = {}
  } = ownerState;
  const slots = {
    root: ['root'],
    badge: ['badge', size, variant, invisible && 'invisible', `anchorOrigin${(0, _utils.unstable_capitalize)(anchorOrigin.vertical)}${(0, _utils.unstable_capitalize)(anchorOrigin.horizontal)}`, `overlap${(0, _utils.unstable_capitalize)(overlap)}`, `color${(0, _utils.unstable_capitalize)(color)}`]
  };
  return (0, _composeClasses.unstable_composeClasses)(slots, _badgeClasses.getBadgeUtilityClass, classes);
};
const BadgeRoot = (0, _styled.default)('span', {
  name: 'MuiBadge',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({
  position: 'relative',
  display: 'inline-flex',
  // For correct alignment with the text.
  verticalAlign: 'middle',
  flexShrink: 0
});
const BadgeBadge = (0, _styled.default)('span', {
  name: 'MuiBadge',
  slot: 'Badge',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.badge, styles[ownerState.size], styles[ownerState.variant], styles[`anchorOrigin${(0, _utils.unstable_capitalize)(ownerState.anchorOrigin.vertical)}${(0, _utils.unstable_capitalize)(ownerState.anchorOrigin.horizontal)}`], styles[`overlap${(0, _utils.unstable_capitalize)(ownerState.overlap)}`], styles[`color${(0, _utils.unstable_capitalize)(ownerState.color)}`], ownerState.invisible && styles.invisible];
  }
})(({
  theme,
  ownerState
}) => {
  const {
    vars: tokens
  } = theme;
  const letterSpacing = `${theme.sys.typescale.label.small.tracking / theme.sys.typescale.label.small.size}rem`;
  const verticalPositionProperty = ownerState.anchorOrigin.vertical === 'top' ? 'bottom' : 'top';
  const horizontalPositionProperty = ownerState.anchorOrigin.horizontal === 'left' ? 'right' : 'left';
  return (0, _extends2.default)({
    '--md-comp-badge-large-size': '16px',
    '--md-comp-badge-small-size': '6px',
    '--md-comp-badge-size': 'var(--md-comp-badge-large-size)',
    '--md-comp-badge-padding-x': '4px',
    '--md-comp-badge-inset': 'calc(var(--md-comp-badge-size) - 4px)'
  }, ownerState.size === 'small' && {
    '--md-comp-badge-size': 'var(--md-comp-badge-small-size)',
    '--md-comp-badge-inset': 'var(--md-comp-badge-size)',
    '--md-comp-badge-padding-x': '0px'
  }, ownerState.overlap === 'circular' && {
    '--md-comp-badge-inset': 'calc(var(--md-comp-badge-size) / 2 + 14%)'
  }, {
    display: 'flex',
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    position: 'absolute',
    boxSizing: 'border-box',
    fontFamily: tokens.sys.typescale.label.small.family,
    fontWeight: tokens.sys.typescale.label.small.weight,
    fontSize: theme.typography.pxToRem(theme.sys.typescale.label.small.size),
    lineHeight: `calc(${tokens.sys.typescale.label.small.lineHeight} / ${tokens.sys.typescale.label.small.size})`,
    letterSpacing,
    backgroundColor: tokens.sys.color[ownerState.color],
    color: tokens.sys.color[`on${(0, _utils.unstable_capitalize)(ownerState.color)}`],
    minWidth: 'var(--md-comp-badge-size)',
    height: 'var(--md-comp-badge-size)',
    paddingRight: `calc(var(--md-comp-badge-padding-x) - ${letterSpacing})`,
    paddingLeft: 'var(--md-comp-badge-padding-x)',
    borderRadius: tokens.sys.shape.corner.full,
    [verticalPositionProperty]: `calc(100% - var(--md-comp-badge-inset))`,
    [horizontalPositionProperty]: `calc(100% - var(--md-comp-badge-inset))`,
    transform: 'scale(1)',
    transformOrigin: 'calc(var(--md-comp-badge-size) / 2)',
    zIndex: 1,
    // Render the badge on top of potential ripples.
    transition: theme.transitions.create('transform', {
      easing: theme.transitions.easing.easeInOut,
      duration: theme.transitions.duration.enteringScreen
    }),
    [`&.${_badgeClasses.default.invisible}`]: {
      transform: 'scale(0)',
      transition: theme.transitions.create('transform', {
        easing: theme.transitions.easing.easeInOut,
        duration: theme.transitions.duration.leavingScreen
      })
    }
  });
});
const defaultLtRAnchorOrigin = {
  vertical: 'top',
  horizontal: 'right'
};
const defaultRtLAnchorOrigin = {
  vertical: 'top',
  horizontal: 'left'
};
function isSmall(size, variant) {
  if (size) {
    // size takes precedence
    return size === 'small';
  }
  return variant === 'dot';
}

/**
 *
 * Demos:
 *
 * - [Badge](https://mui.com/material-ui/react-badge/)
 *
 * API:
 *
 * - [Badge API](https://mui.com/material-ui/api/badge/)
 */
const Badge = /*#__PURE__*/React.forwardRef(function Badge(inProps, ref) {
  var _slots$root, _slots$badge;
  const props = (0, _useThemeProps.default)({
    props: inProps,
    name: 'MuiBadge'
  });
  const theme = (0, _useTheme.default)();
  const defaultAnchorOrigin = theme.direction === 'rtl' ? defaultRtLAnchorOrigin : defaultLtRAnchorOrigin;
  const {
      anchorOrigin: anchorOriginProp = defaultAnchorOrigin,
      className,
      component,
      children,
      overlap: overlapProp = 'rectangular',
      color: colorProp = 'error',
      invisible: invisibleProp = false,
      max: maxProp = 99,
      badgeContent: badgeContentProp,
      slots = {},
      slotProps = {},
      showZero = false,
      size: sizeProp,
      variant: variantProp
    } = props,
    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max,
    displayValue: displayValueFromHook
  } = (0, _useBadge.useBadge)({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = (0, _utils.usePreviousProps)({
    anchorOrigin: anchorOriginProp,
    color: colorProp,
    overlap: overlapProp,
    size: sizeProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && !isSmall(sizeProp, variantProp);
  const {
    color = colorProp,
    overlap = overlapProp,
    anchorOrigin = anchorOriginProp,
    size = sizeProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const displayValue = !isSmall(size, variant) ? displayValueFromHook : undefined;
  const ownerState = (0, _extends2.default)({}, props, {
    badgeContent,
    invisible,
    max,
    displayValue,
    showZero,
    anchorOrigin,
    color,
    overlap,
    size: isSmall(size, variant) ? 'small' : 'large',
    variant: isSmall(size, variant) ? 'dot' : 'standard'
  });
  const classes = useUtilityClasses(ownerState);
  const RootSlot = (_slots$root = slots.root) != null ? _slots$root : BadgeRoot;
  const BadgeSlot = (_slots$badge = slots.badge) != null ? _slots$badge : BadgeBadge;
  const rootProps = (0, _base.useSlotProps)({
    elementType: RootSlot,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: [classes.root, className]
  });
  const badgeProps = (0, _base.useSlotProps)({
    elementType: BadgeSlot,
    externalSlotProps: slotProps.badge,
    ownerState,
    className: classes.badge
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(RootSlot, (0, _extends2.default)({}, rootProps, {
    children: [children, /*#__PURE__*/(0, _jsxRuntime.jsx)(BadgeSlot, (0, _extends2.default)({}, badgeProps, {
      children: displayValue
    }))]
  }));
});
process.env.NODE_ENV !== "production" ? Badge.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The anchor of the badge.
   * @default {
   *   vertical: 'top',
   *   horizontal: 'right',
   * }
   */
  anchorOrigin: _propTypes.default.shape({
    horizontal: _propTypes.default.oneOf(['left', 'right']).isRequired,
    vertical: _propTypes.default.oneOf(['bottom', 'top']).isRequired
  }),
  /**
   * The content rendered within the badge.
   */
  badgeContent: _propTypes.default.node,
  /**
   * The badge will be added relative to this node.
   */
  children: _propTypes.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: _propTypes.default.object,
  /**
   * @ignore
   */
  className: _propTypes.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'error'
   */
  color: _propTypes.default /* @typescript-to-proptypes-ignore */.oneOfType([_propTypes.default.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'tertiary', 'warning']), _propTypes.default.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: _propTypes.default.elementType,
  /**
   * If `true`, the badge is invisible.
   * @default false
   */
  invisible: _propTypes.default.bool,
  /**
   * Max count to show.
   * @default 99
   */
  max: _propTypes.default.number,
  /**
   * Wrapped shape the badge should overlap.
   * @default 'rectangular'
   */
  overlap: _propTypes.default.oneOf(['circular', 'rectangular']),
  /**
   * Controls whether the badge is hidden when `badgeContent` is zero.
   * @default false
   */
  showZero: _propTypes.default.bool,
  /**
   * The size to use.
   * @default 'large'
   */
  size: _propTypes.default /* @typescript-to-proptypes-ignore */.oneOfType([_propTypes.default.oneOf(['small', 'large']), _propTypes.default.string]),
  /**
   * The props used for each slot inside the Badge.
   * @default {}
   */
  slotProps: _propTypes.default.shape({
    badge: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),
    root: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object])
  }),
  /**
   * The components used for each slot inside the Badge.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: _propTypes.default.shape({
    badge: _propTypes.default.elementType,
    root: _propTypes.default.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object, _propTypes.default.bool])), _propTypes.default.func, _propTypes.default.object]),
  /**
   * The variant to use.
   * @default 'standard'
   * @deprecated Use `size = 'small' | 'large'` instead
   */
  variant: _propTypes.default /* @typescript-to-proptypes-ignore */.oneOfType([_propTypes.default.oneOf(['dot', 'standard']), _propTypes.default.string])
} : void 0;
var _default = exports.default = Badge;